name: kinc CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

# Global configuration - single source of truth for cluster list
env:
  CLUSTER_LIST: "dev staging"

jobs:
  test-multi-cluster:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        config_mode: [mounted, baked-in]
    
    name: Test (${{ matrix.config_mode }} config)
    
    steps:
      - name: Checkout kinc
        uses: actions/checkout@v4

      - name: Enable IP forwarding
        run: echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward

      - name: Build single base image (Phase 2 - all clusters use same image)
        run: |
          echo "=== Building single base image for all clusters ==="
          echo "Phase 2: One image, multiple configs (mounted or baked-in)"
          
          # Build single base image
          echo "Building kinc base image..."
          bash ./tools/build.sh
          
          echo "=== Image build summary ==="
          podman images localhost/kinc/node
          
          echo "âœ… Single image built successfully"
          echo "All clusters will use: localhost/kinc/node:v1.33.5"
        shell: bash

      - name: Deploy clusters with ${{ matrix.config_mode }} configuration
        run: |
          echo "=== Deploying clusters with ${{ matrix.config_mode }} configuration ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          # Set config mode environment variable
          if [ "${{ matrix.config_mode }}" = "baked-in" ]; then
            export USE_BAKED_IN_CONFIG=true
            echo "ðŸ“‹ Using baked-in configuration (embedded in image)"
          else
            echo "ðŸ“‹ Using mounted configuration (external volume)"
          fi
          
          # Deploy clusters sequentially to avoid port conflicts
          for cluster in $CLUSTERS; do
            echo "ðŸš€ Starting deployment of $cluster cluster..."
            
            # Start deployment in background
            CLUSTER_NAME=$cluster bash ./tools/deploy-and-test.sh > /tmp/deploy-${cluster}.log 2>&1 &
            deploy_pid=$!
            echo "Deploy PID: $deploy_pid"
            
            # Wait for this cluster's port to be bound before starting next
            echo "â³ Waiting for $cluster cluster port to be bound..."
            max_wait=600  # 10 minutes
            waited=0
            cluster_port=""
            
            while [ $waited -lt $max_wait ]; do
              # Check if deployment process is still running
              if ! kill -0 $deploy_pid 2>/dev/null; then
                # Process finished, check if it succeeded
                if wait $deploy_pid; then
                  echo "âœ… $cluster deployment process completed"
                else
                  echo "âŒ $cluster deployment process failed"
                  cat /tmp/deploy-${cluster}.log || true
                  exit 1
                fi
              fi
              
              # Check if container exists and has bound port
              if podman ps --format "{{.Names}}" | grep -q "^kinc-${cluster}-control-plane$"; then
                # Extract the actual bound port from container inspect
                cluster_port=$(podman inspect kinc-${cluster}-control-plane --format '{{range $p, $conf := .NetworkSettings.Ports}}{{range $conf}}{{.HostPort}}{{end}}{{end}}' 2>/dev/null)
                if [[ -n "$cluster_port" && "$cluster_port" =~ ^[0-9]+$ ]]; then
                  echo "âœ… $cluster cluster bound to port $cluster_port"
                  echo "${cluster^^}_PORT=$cluster_port" >> $GITHUB_ENV
                  echo "ðŸš€ Port secured, can start next cluster (API server will initialize in background)"
                  break
                else
                  echo "â³ $cluster container port not bound yet..."
                fi
              else
                echo "â³ $cluster container not running yet..."
              fi
              
              sleep 5
              waited=$((waited + 5))
            done
            
            # Check if we successfully got the port
            if [[ -z "$cluster_port" ]]; then
              echo "âŒ CRITICAL: $cluster cluster failed to bind port within timeout!"
              cat /tmp/deploy-${cluster}.log || true
              exit 1
            fi
            
            echo "âœ… $cluster cluster port secured ($cluster_port), proceeding to next cluster..."
          done
          
          echo "âœ… All clusters deployed sequentially with unique ports"
          echo "Configuration mode: ${{ matrix.config_mode }}"
        shell: bash

      - name: Wait for all clusters to be ready
        run: |
          echo "=== Waiting for all clusters to be ready ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          for cluster in $CLUSTERS; do
            # Get port from environment variable
            port_var="${cluster^^}_PORT"
            port=${!port_var}
            
            echo "â³ Waiting for $cluster cluster API server to be ready (port $port)..."
            
            # Wait for API server to respond
            max_attempts=60  # 5 minutes
            for i in $(seq 1 $max_attempts); do
              if curl -k -s https://127.0.0.1:$port/healthz >/dev/null 2>&1; then
                echo "âœ… $cluster cluster API server ready on port $port"
                break
              fi
              
              if [ $((i % 12)) -eq 0 ]; then  # Every minute
                echo "Still waiting for $cluster API server... (attempt $i/$max_attempts)"
              fi
              sleep 5
            done
            
            # Verify API server is responding
            if ! curl -k -s https://127.0.0.1:$port/healthz >/dev/null 2>&1; then
              echo "âŒ $cluster cluster API server failed to become ready after $max_attempts attempts"
              exit 1
            fi
          done
          
          echo "âœ… All cluster API servers are ready"
        shell: bash

      - name: Extract kubeconfigs
        run: |
          echo "=== Extracting kubeconfigs for all clusters ==="
          mkdir -p ~/.kube
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          for cluster in $CLUSTERS; do
            # Get port from environment variable
            port_var="${cluster^^}_PORT"
            port=${!port_var}
            
            echo "Extracting kubeconfig for $cluster cluster (port $port)..."
            
            # Extract kubeconfig
            podman cp kinc-${cluster}-control-plane:/etc/kubernetes/admin.conf ~/.kube/config-kinc-${cluster}
            
            # Update server URL with actual port
            sed -i "s|server: https://.*:6443|server: https://127.0.0.1:$port|g" ~/.kube/config-kinc-${cluster}
            
            echo "âœ… $cluster cluster kubeconfig: ~/.kube/config-kinc-${cluster} (port $port)"
          done
        shell: bash

      - name: Verify configuration mode
        run: |
          echo "=== Verifying configuration mode: ${{ matrix.config_mode }} ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          for cluster in $CLUSTERS; do
            echo "Checking $cluster cluster configuration source..."
            
            # Check for config volume mount
            has_config_volume=$(podman inspect kinc-${cluster}-control-plane --format '{{range .Mounts}}{{if eq .Destination "/etc/kinc/config"}}yes{{end}}{{end}}' 2>/dev/null || echo "no")
            
            # Check logs for configuration source
            config_source=$(podman logs kinc-${cluster}-control-plane 2>&1 | grep -oP '(Using mounted configuration|No mounted config found, using baked-in configuration)' | head -1)
            
            echo "$cluster cluster:"
            echo "  Config volume mounted: $has_config_volume"
            echo "  Configuration source: $config_source"
            
            # Verify configuration matches test matrix
            if [ "${{ matrix.config_mode }}" = "baked-in" ]; then
              if [[ "$config_source" == *"baked-in"* ]]; then
                echo "âœ… $cluster using baked-in configuration as expected"
              else
                echo "âŒ $cluster expected baked-in config but found: $config_source"
                exit 1
              fi
            else
              if [[ "$config_source" == *"mounted"* ]]; then
                echo "âœ… $cluster using mounted configuration as expected"
              else
                echo "âŒ $cluster expected mounted config but found: $config_source"
                exit 1
              fi
            fi
          done
          
          echo "âœ… Configuration mode verification passed: ${{ matrix.config_mode }}"
        shell: bash

      - name: Validate multi-cluster isolation
        run: |
          echo "=== Validating multi-cluster isolation ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          # Check all services are active
          for cluster in $CLUSTERS; do
            echo "Checking $cluster cluster service..."
            systemctl --user is-active kinc-${cluster}-control-plane.service
          done
          
          # Check all containers are running
          for cluster in $CLUSTERS; do
            echo "Checking $cluster cluster container..."
            podman ps --filter "name=kinc-${cluster}-control-plane" --format "{{.Names}} {{.Status}}"
          done
          
          # Collect all ports and validate API servers
          declare -A cluster_ports
          
          for cluster in $CLUSTERS; do
            # Get port from environment variable
            port_var="${cluster^^}_PORT"
            port=${!port_var}
            cluster_ports[$cluster]=$port
            
            echo "$cluster cluster port: $port"
            
            # Verify API server responds
            if curl -k -s https://127.0.0.1:$port/healthz >/dev/null 2>&1; then
              echo "âœ… $cluster cluster API ($port) responding"
            else
              echo "âŒ $cluster cluster API ($port) not responding"
              exit 1
            fi
          done
          
          # Show all ports in netstat
          all_ports=$(printf "%s|" "${cluster_ports[@]}")
          all_ports=${all_ports%|}  # Remove trailing |
          echo "=== Active ports ==="
          netstat -tlnp | grep -E ":($all_ports)" || true
          
          # Verify all ports are unique
          echo "=== Verifying port isolation ==="
          ports_list=(${cluster_ports[@]})
          unique_ports=($(printf "%s\n" "${ports_list[@]}" | sort -u))
          
          if [ ${#ports_list[@]} -eq ${#unique_ports[@]} ]; then
            echo "âœ… All ${#ports_list[@]} cluster ports are unique"
            for cluster in $CLUSTERS; do
              echo "  $cluster: ${cluster_ports[$cluster]}"
            done
          else
            echo "âŒ Port collision detected among ${#ports_list[@]} clusters!"
            for cluster in $CLUSTERS; do
              echo "  $cluster: ${cluster_ports[$cluster]}"
            done
            exit 1
          fi
          
          echo "âœ… Multi-cluster isolation validated"
        shell: bash

      - name: Test cluster isolation
        run: |
          echo "=== Testing cluster isolation ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          clusters_array=($CLUSTERS)
          
          # Use first cluster to create namespace
          first_cluster=${clusters_array[0]}
          echo "Creating test namespace in $first_cluster cluster..."
          export KUBECONFIG=~/.kube/config-kinc-${first_cluster}
          kubectl create namespace isolation-test
          
          # Verify namespace doesn't exist in other clusters
          for cluster in $CLUSTERS; do
            if [ "$cluster" != "$first_cluster" ]; then
              echo "Checking that namespace doesn't exist in $cluster cluster..."
              export KUBECONFIG=~/.kube/config-kinc-${cluster}
              if kubectl get namespace isolation-test 2>/dev/null; then
                echo "âŒ Namespace leaked from $first_cluster to $cluster cluster"
                exit 1
              else
                echo "âœ… Namespace properly isolated from $cluster cluster"
              fi
            fi
          done
          
          echo "âœ… Cluster isolation verified across all ${#clusters_array[@]} clusters"
        shell: bash

      - name: Validate clusters functionality
        run: |
          echo "=== Validating all clusters functionality ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          for cluster in $CLUSTERS; do
            echo "=== Testing $cluster cluster ==="
            export KUBECONFIG=~/.kube/config-kinc-${cluster}
            
            echo "Cluster info:"
            kubectl cluster-info
            
            echo "Node status:"
            kubectl get nodes -o wide
            
            echo "System pods:"
            kubectl get pods -A
            
            echo "âœ… $cluster cluster validation complete"
          done
        shell: bash

      - name: Collect diagnostics
        if: always()
        run: |
          echo "=== Collecting diagnostics ==="
          mkdir -p artifacts
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          # Deployment logs
          for cluster in $CLUSTERS; do
            if [ -f "/tmp/deploy-${cluster}.log" ]; then
              cp /tmp/deploy-${cluster}.log artifacts/deploy-${cluster}.log
            fi
          done
          
          # System diagnostics
          for cluster in $CLUSTERS; do
            echo "Collecting diagnostics for $cluster cluster..."
            
            # systemd service status
            systemctl --user status kinc-${cluster}-control-plane.service > artifacts/${cluster}-systemd-status.txt 2>&1 || true
            
            # systemd service logs
            journalctl --user -xeu kinc-${cluster}-control-plane.service --no-pager > artifacts/${cluster}-systemd-logs.txt 2>&1 || true
            
            # Container logs
            podman logs kinc-${cluster}-control-plane > artifacts/${cluster}-container.log 2>&1 || true
            
            # Cluster info
            export KUBECONFIG=~/.kube/config-kinc-${cluster}
            kubectl cluster-info dump > artifacts/${cluster}-cluster-info.txt 2>&1 || true
            kubectl get all -A > artifacts/${cluster}-resources.txt 2>&1 || true
            kubectl get events -A --sort-by='.lastTimestamp' > artifacts/${cluster}-events.txt 2>&1 || true
          done
          
          # System info
          netstat -tlnp > artifacts/network-ports.txt 2>&1 || true
          ip addr show > artifacts/network-interfaces.txt 2>&1 || true
          systemctl --user --failed > artifacts/systemd-failed-units.txt 2>&1 || true
        shell: bash

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kinc-diagnostics-${{ matrix.config_mode }}-${{ github.run_number }}
          path: artifacts/
          retention-days: 30

      - name: Cleanup all clusters
        if: always()
        run: |
          echo "=== Cleaning up all clusters ==="
          
          CLUSTERS="${{ env.CLUSTER_LIST }}"
          
          for cluster in $CLUSTERS; do
            echo "Cleaning up $cluster cluster..."
            CLUSTER_NAME=$cluster bash ./tools/cleanup.sh || true
          done
        shell: bash
