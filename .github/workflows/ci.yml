name: kinc CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  test-multi-cluster:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout kinc
        uses: actions/checkout@v4

      - name: Enable IP forwarding
        run: echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward

      - name: Build base and cluster images efficiently
        run: |
          echo "=== Building base and cluster images efficiently ==="
          
          # üéØ CLUSTER CONFIGURATION - Add/remove clusters here
          # Supports any number of clusters: 2, 5, 10, etc.
          CLUSTERS="default dev staging"
          # To add production: CLUSTERS="default dev staging prod"
          # To add more: CLUSTERS="default dev staging prod test qa"
          
          # Build base image first
          echo "Building base image..."
          bash ./tools/build.sh
          
          # Build cluster-specific images (will reuse base layers)
          for cluster in $CLUSTERS; do
            if [ "$cluster" != "default" ]; then
              echo "Building $cluster cluster image (reusing base layers)..."
              CLUSTER_NAME=$cluster bash ./tools/build.sh
            fi
          done
          
          echo "=== Image build summary ==="
          podman images localhost/kinc/node
        shell: bash

      - name: Deploy clusters in parallel using background jobs
        run: |
          echo "=== Deploying clusters in parallel ==="
          
          # üéØ CLUSTER CONFIGURATION - Must match build step
          CLUSTERS="dev staging"
          # To add production: CLUSTERS="dev staging prod"
          # To add more: CLUSTERS="dev staging prod test qa"
          
          
          # Deploy clusters sequentially to avoid port conflicts
          for cluster in $CLUSTERS; do
            echo "üöÄ Starting deployment of $cluster cluster..."
            
            # Start deployment in background
            CLUSTER_NAME=$cluster bash ./tools/full-deploy.sh > /tmp/deploy-${cluster}.log 2>&1 &
            deploy_pid=$!
            echo "Deploy PID: $deploy_pid"
            
            # Wait for this cluster's port to be bound before starting next
            echo "‚è≥ Waiting for $cluster cluster port to be bound..."
            max_wait=600  # 10 minutes
            waited=0
            cluster_port=""
            
            while [ $waited -lt $max_wait ]; do
              # Check if deployment process is still running
              if ! kill -0 $deploy_pid 2>/dev/null; then
                # Process finished, check if it succeeded
                if wait $deploy_pid; then
                  echo "‚úÖ $cluster deployment process completed"
                else
                  echo "‚ùå $cluster deployment process failed"
                  cat /tmp/deploy-${cluster}.log || true
                  exit 1
                fi
              fi
              
              # Check if container exists and has bound port
              if podman ps --format "{{.Names}}" | grep -q "^kinc-${cluster}-control-plane$"; then
                # Extract the actual bound port from container inspect
                cluster_port=$(podman inspect kinc-${cluster}-control-plane --format '{{range $p, $conf := .NetworkSettings.Ports}}{{range $conf}}{{.HostPort}}{{end}}{{end}}' 2>/dev/null)
                if [[ -n "$cluster_port" && "$cluster_port" =~ ^[0-9]+$ ]]; then
                  echo "‚úÖ $cluster cluster bound to port $cluster_port"
                  echo "${cluster^^}_PORT=$cluster_port" >> $GITHUB_ENV
                  echo "üöÄ Port secured, can start next cluster (API server will initialize in background)"
                  break
                else
                  echo "‚è≥ $cluster container port not bound yet..."
                fi
              else
                echo "‚è≥ $cluster container not running yet..."
              fi
              
              sleep 5
              waited=$((waited + 5))
            done
            
            # Check if we successfully got the port
            if [[ -z "$cluster_port" ]]; then
              echo "‚ùå CRITICAL: $cluster cluster failed to bind port within timeout!"
              cat /tmp/deploy-${cluster}.log || true
              exit 1
            fi
            
            echo "‚úÖ $cluster cluster port secured ($cluster_port), proceeding to next cluster..."
          done
          
          echo "‚úÖ All clusters deployed sequentially with unique ports"
        shell: bash


      - name: Wait for all clusters to be ready
        run: |
          echo "=== Waiting for all clusters to be ready ==="
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          
          for cluster in $CLUSTERS; do
            # Get port from environment variable
            port_var="${cluster^^}_PORT"
            port=${!port_var}
            
            echo "‚è≥ Waiting for $cluster cluster API server to be ready (port $port)..."
            
            # Wait for API server to respond
            max_attempts=60  # 5 minutes
            for i in $(seq 1 $max_attempts); do
              if curl -k -s https://127.0.0.1:$port/healthz >/dev/null 2>&1; then
                echo "‚úÖ $cluster cluster API server ready on port $port"
                break
              fi
              
              if [ $((i % 12)) -eq 0 ]; then  # Every minute
                echo "Still waiting for $cluster API server... (attempt $i/$max_attempts)"
              fi
              sleep 5
            done
            
            # Verify API server is responding
            if ! curl -k -s https://127.0.0.1:$port/healthz >/dev/null 2>&1; then
              echo "‚ùå $cluster cluster API server failed to become ready after $max_attempts attempts"
              exit 1
            fi
          done
          
          echo "‚úÖ All cluster API servers are ready"
        shell: bash

      - name: Extract kubeconfigs
        run: |
          echo "=== Extracting kubeconfigs for all clusters ==="
          mkdir -p ~/.kube
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          
          for cluster in $CLUSTERS; do
            # Get port from environment variable
            port_var="${cluster^^}_PORT"
            port=${!port_var}
            
            echo "Extracting kubeconfig for $cluster cluster (port $port)..."
            
            # Extract kubeconfig
            podman cp kinc-${cluster}-control-plane:/etc/kubernetes/admin.conf ~/.kube/config-kinc-${cluster}
            
            # Update server URL with actual port
            sed -i "s|server: https://.*:6443|server: https://127.0.0.1:$port|g" ~/.kube/config-kinc-${cluster}
            
            echo "‚úÖ $cluster cluster kubeconfig: ~/.kube/config-kinc-${cluster} (port $port)"
          done
        shell: bash

      - name: Validate multi-cluster isolation
        run: |
          echo "=== Validating multi-cluster isolation ==="
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          
          # Check all services are active
          for cluster in $CLUSTERS; do
            echo "Checking $cluster cluster service..."
            systemctl --user is-active kinc-${cluster}-control-plane.service
          done
          
          # Check all containers are running
          for cluster in $CLUSTERS; do
            echo "Checking $cluster cluster container..."
            podman ps --filter "name=kinc-${cluster}-control-plane" --format "{{.Names}} {{.Status}}"
          done
          
          # Collect all ports and validate API servers
          declare -A cluster_ports
          
          for cluster in $CLUSTERS; do
            # Get port from environment variable
            port_var="${cluster^^}_PORT"
            port=${!port_var}
            cluster_ports[$cluster]=$port
            
            echo "$cluster cluster port: $port"
            
            # Verify API server responds
            if curl -k -s https://127.0.0.1:$port/healthz >/dev/null 2>&1; then
              echo "‚úÖ $cluster cluster API ($port) responding"
            else
              echo "‚ùå $cluster cluster API ($port) not responding"
              exit 1
            fi
          done
          
          # Show all ports in netstat
          all_ports=$(printf "%s|" "${cluster_ports[@]}")
          all_ports=${all_ports%|}  # Remove trailing |
          echo "=== Active ports ==="
          netstat -tlnp | grep -E ":($all_ports)" || true
          
          # Verify all ports are unique
          echo "=== Verifying port isolation ==="
          ports_list=(${cluster_ports[@]})
          unique_ports=($(printf "%s\n" "${ports_list[@]}" | sort -u))
          
          if [ ${#ports_list[@]} -eq ${#unique_ports[@]} ]; then
            echo "‚úÖ All ${#ports_list[@]} cluster ports are unique"
            for cluster in $CLUSTERS; do
              echo "  $cluster: ${cluster_ports[$cluster]}"
            done
          else
            echo "‚ùå Port collision detected among ${#ports_list[@]} clusters!"
            for cluster in $CLUSTERS; do
              echo "  $cluster: ${cluster_ports[$cluster]}"
            done
            exit 1
          fi
          
          echo "‚úÖ Multi-cluster isolation validated"
        shell: bash

      - name: Test cluster isolation
        run: |
          echo "=== Testing cluster isolation ==="
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          clusters_array=($CLUSTERS)
          
          # Use first cluster to create namespace
          first_cluster=${clusters_array[0]}
          echo "Creating test namespace in $first_cluster cluster..."
          export KUBECONFIG=~/.kube/config-kinc-${first_cluster}
          kubectl create namespace isolation-test
          
          # Verify namespace doesn't exist in other clusters
          for cluster in $CLUSTERS; do
            if [ "$cluster" != "$first_cluster" ]; then
              echo "Checking that namespace doesn't exist in $cluster cluster..."
              export KUBECONFIG=~/.kube/config-kinc-${cluster}
              if kubectl get namespace isolation-test 2>/dev/null; then
                echo "‚ùå Namespace leaked from $first_cluster to $cluster cluster"
                exit 1
              else
                echo "‚úÖ Namespace properly isolated from $cluster cluster"
              fi
            fi
          done
          
          echo "‚úÖ Cluster isolation verified across all ${#clusters_array[@]} clusters"
        shell: bash

      - name: Validate clusters functionality
        run: |
          echo "=== Validating all clusters functionality ==="
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          
          for cluster in $CLUSTERS; do
            echo "=== Testing $cluster cluster ==="
            export KUBECONFIG=~/.kube/config-kinc-${cluster}
            
            echo "Cluster info:"
            kubectl cluster-info
            
            echo "Node status:"
            kubectl get nodes -o wide
            
            echo "System pods:"
            kubectl get pods -A
            
            echo "‚úÖ $cluster cluster validation complete"
          done
        shell: bash

      - name: Collect diagnostics
        if: always()
        run: |
          echo "=== Collecting diagnostics ==="
          mkdir -p artifacts
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          
          # Deployment logs
          for cluster in $CLUSTERS; do
            if [ -f "/tmp/deploy-${cluster}.log" ]; then
              cp /tmp/deploy-${cluster}.log artifacts/deploy-${cluster}.log
            fi
          done
          
          # System diagnostics
          for cluster in $CLUSTERS; do
            echo "Collecting diagnostics for $cluster cluster..."
            
            # systemd service status
            systemctl --user status kinc-${cluster}-control-plane.service > artifacts/${cluster}-systemd-status.txt 2>&1 || true
            
            # systemd service logs
            journalctl --user -xeu kinc-${cluster}-control-plane.service --no-pager > artifacts/${cluster}-systemd-logs.txt 2>&1 || true
            
            # Container logs
            podman logs kinc-${cluster}-control-plane > artifacts/${cluster}-container.log 2>&1 || true
            
            # Cluster info
            export KUBECONFIG=~/.kube/config-kinc-${cluster}
            kubectl cluster-info dump > artifacts/${cluster}-cluster-info.txt 2>&1 || true
            kubectl get all -A > artifacts/${cluster}-resources.txt 2>&1 || true
            kubectl get events -A --sort-by='.lastTimestamp' > artifacts/${cluster}-events.txt 2>&1 || true
          done
          
          # System info
          netstat -tlnp > artifacts/network-ports.txt 2>&1 || true
          ip addr show > artifacts/network-interfaces.txt 2>&1 || true
          systemctl --user --failed > artifacts/systemd-failed-units.txt 2>&1 || true
        shell: bash

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kinc-diagnostics-${{ github.run_number }}
          path: artifacts/
          retention-days: 30

      - name: Cleanup all clusters
        if: always()
        run: |
          echo "=== Cleaning up all clusters ==="
          
          # üéØ CLUSTER CONFIGURATION - Must match deploy step
          CLUSTERS="dev staging"
          
          for cluster in $CLUSTERS; do
            echo "Cleaning up $cluster cluster..."
            CLUSTER_NAME=$cluster bash ./tools/cleanup.sh || true
          done
        shell: bash